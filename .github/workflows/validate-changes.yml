name: Validate Pull Request

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]
    branches:
      - main
      - uat
      
    paths:
      - 'force-app/**'
jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Mark repo directory as safe
        run: |
          git config --global --add safe.directory /__w/sf-pipeline-test/sf-pipeline-test

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for diff
  
      - name: check latest commit is merge commit
        id: check-merge-commit
        run: |
          feature_branch="${{ github.head_ref }}"
          if git log "origin/$feature_branch" -1 --pretty=%B | grep -q "Merge branch "; then
            echo "is-merge-resolved=true" >> $GITHUB_OUTPUT 
          else
            echo "Latest commit is not a merge commit"
          fi
 
          
      - name: Get Commit id for feature (before merge commit)
        if: steps.check-merge-commit.outputs.is-merge-resolved == 'true'
        id: get-feature-commit
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });
            
            console.log(`Total commits in PR: ${commits.length}`);
            
            if (commits.length < 2) {
              console.log("PR has less than 2 commits, using the only commit");
              return;
            }
            
            // Get second to last commit (before merge commit)
            const featureCommit = commits[commits.length - 2].sha;
            console.log(`Second to last commit: ${featureCommit}`);
            console.log(`Commit message: ${commits[commits.length - 2].commit.message}`);
            
            core.setOutput('latest-feature-commit', featureCommit); 

      - name: Check if branch name starts with 'Release'
        id: check-branch
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [[ "${{ github.head_ref }}" != Release* && "${{ github.base_ref }}" == "main" ]]; then
            echo "Error: Branch name must start with 'Release' when targeting main."

            echo "Posting pre-deployment steps as a comment on PR #${{ github.event.pull_request.number }}..."
            
            # Create a comment with the pre-deployment steps and capture the comment ID
            COMMENT_URL=$(gh pr comment ${{ github.event.pull_request.number }} --body "## ðŸš¨ðŸš¨ðŸš¨ Merge is Blocked ðŸš¨ðŸš¨ðŸš¨

            The PR is raised against the **main** branch, which is reserved for production releases.

            only branches starting with **\`Release\`** are allowed to merge into **main**.

            please make sure that you are creating PR to the correct target branch.
            
            ---
            *This comment was automatically generated by the GitHub Actions workflow.*")

            exit 1
          else
            echo "branch-valid=true" >> $GITHUB_OUTPUT
            echo "Branch name is valid."
          fi

      - name: Fetch base and head branches
        run: |
          git fetch origin main
          git fetch origin ${{ github.head_ref }}
      
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Check if pre-deployment steps exist
        id: check-pre-deployment
        run: |
          if [ -s "deployment-steps/pre-deployement-steps.txt" ]; then
            echo "has-pre-deployment-steps=true" >> $GITHUB_OUTPUT
          else
            echo "has-pre-deployment-steps=false" >> $GITHUB_OUTPUT
          fi

      - name: Display pre-deployment steps
        if: steps.check-pre-deployment.outputs.has-pre-deployment-steps == 'true'
        id: post-comment
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Posting pre-deployment steps as a comment on PR #${{ github.event.pull_request.number }}..."
          
          # Read the pre-deployment steps content
          STEPS_CONTENT=$(cat deployment-steps/pre-deployement-steps.txt)
          
          # Create a comment with the pre-deployment steps and capture the comment ID
          COMMENT_URL=$(gh pr comment ${{ github.event.pull_request.number }} --body "## ðŸš€ Pre-deployment Steps Required

          Please complete the following steps before approving this workflow:

          \`\`\`
          $STEPS_CONTENT
          \`\`\`


          ---
          *This comment was automatically generated by the GitHub Actions workflow.*")

      - name: Install SFDX and plugins
        run: |
          npm install --no-cache @salesforce/cli --global
          sf plugins install @salesforce/plugin-packaging
          echo 'y' | sf plugins install sfdx-git-delta
      
      - name: Compute changed files
        id: changed-files
        run: |
          if [[ -n "${{ steps.get-feature-commit.outputs.latest-feature-commit }}" ]]; then
              BASE_COMMIT=$(git merge-base origin/main ${{ steps.get-feature-commit.outputs.latest-feature-commit }})
              echo "Base commit: $BASE_COMMIT"
              sf sgd source delta -f $BASE_COMMIT -t ${{ steps.get-feature-commit.outputs.latest-feature-commit }} --output-dir .
          else
              BASE_COMMIT=$(git merge-base origin/main origin/${{ github.head_ref }})
              echo "Base commit: $BASE_COMMIT"
              sf sgd source delta -f $BASE_COMMIT -t origin/${{ github.head_ref }} --output-dir .
          fi

          cat package/package.xml
          cat destructiveChanges/destructiveChanges.xml

      - name: Check test_classes.txt content
        id: check-test-classes
        run: |
          if [ -s "test_classes.txt" ]; then
            echo "test_classes.txt has content:"
            cat test_classes.txt
            echo "has-test-classes=true" >> $GITHUB_OUTPUT

            # Read test classes and format them for SF CLI
            TEST_CLASSES=$(cat test_classes.txt | tr '\n' ' --tests ' | sed 's/,$//')
            TEST_CLASSES=$(echo "$TEST_CLASSES" | perl -pe 's/[\x00-\x1F\x7F\xA0]//g')
            echo "Clean String:"
            echo "$TEST_CLASSES" | cat -v
            CLASS_ARGS=""
            for cls in $TEST_CLASSES; do
              CLASS_ARGS="$CLASS_ARGS --tests $cls"
            done

            echo "$CLASS_ARGS"

            echo "test-classes=$CLASS_ARGS" >> $GITHUB_OUTPUT
            echo "Formatted test classes: $CLASS_ARGS"
          else
            echo "test_classes.txt is empty or does not exist"
            echo "has-test-classes=false" >> $GITHUB_OUTPUT
          fi

      - name: Set Destination Org and login to org
        run: |
          if [[ "${GITHUB_BASE_REF}" == "uat" ]]; then
            echo ${{ secrets.SFDX_AUTH_URL_UAT}} > ./SFDX_URL_STORE.txt
            echo "UAT Login is Selected"
          elif [[ "${GITHUB_BASE_REF}" == "main" ]]; then
            echo ${{ secrets.SFDX_AUTH_URL_PROD}} > ./SFDX_URL_STORE.txt
            echo "Production Login is Selected"
          else
            echo "Invalid branch: ${GITHUB_BASE_REF}" 
            exit 1
          fi
          sf org login sfdx-url --sfdx-url-file=./SFDX_URL_STORE.txt -s

      - name: Validate Against the Org
        run: |
          if [[ "${GITHUB_BASE_REF}" == "main" ]]; then
            echo "Production Deployment, Running all local tests"
            sf project deploy start --dry-run -x package/package.xml --post-destructive-changes destructiveChanges/destructiveChanges.xml -l RunLocalTests --coverage-formatters text
            echo "Code Coverage Report:"
            cat coverage/coverage/text.txt
          else
            # For non-production deployments, use specific test classes if available
            if [[ "${{ steps.check-test-classes.outputs.has-test-classes }}" == "true" ]]; then
              echo "Running deployment with specific test classes: ${{ steps.check-test-classes.outputs.test-classes }}"
              sf project deploy start --dry-run -x package/package.xml --post-destructive-changes destructiveChanges/destructiveChanges.xml -l RunSpecifiedTests ${{ steps.check-test-classes.outputs.test-classes }} --coverage-formatters text
              echo "Code Coverage Report:"
              cat coverage/coverage/text.txt
            else
              echo "No specific test classes found, running without specific tests"
              sf project deploy start --dry-run -x package/package.xml --post-destructive-changes destructiveChanges/destructiveChanges.xml
            fi
          fi

      - name: Check if Post-deployment steps exist
        id: check-post-deployment
        run: |
          if [ -s "deployment-steps/post-deployement-steps.txt" ]; then
            echo "has-post-deployment-steps=true" >> $GITHUB_OUTPUT
          else
            echo "has-post-deployment-steps=false" >> $GITHUB_OUTPUT
          fi

      - name: Display post-deployment steps
        if: steps.check-post-deployment.outputs.has-post-deployment-steps == 'true'
        id: post-comment1
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Posting post-deployment steps as a comment on PR #${{ github.event.pull_request.number }}..."

          # Read the post-deployment steps content
          STEPS_CONTENT=$(cat deployment-steps/post-deployment-steps.txt)

          # Create a comment with the post-deployment steps and capture the comment ID
          COMMENT_URL=$(gh pr comment ${{ github.event.pull_request.number }} --body "## ðŸš€ Post-deployment Steps Required

          Please complete the following steps before approving this workflow:

          \`\`\`
          $STEPS_CONTENT
          \`\`\`


          ---
          *This comment was automatically generated by the GitHub Actions workflow.*")
        
      - name: Upload Deployment Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-artifacts
          path: |
            package/
            destructiveChanges/
            coverage/
